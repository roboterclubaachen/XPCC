/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 * ------------------------------------------------------------------------- */

%%	import '../generic/static.macros' as macro with context

#ifndef XPCC_STM32_CLOCK_SOURCES_HPP
#define XPCC_STM32_CLOCK_SOURCES_HPP

#include <stdint.h>		// uint32_t
#include "../../../device.hpp"
#include "../../../type_ids.hpp"
#include "../generic/common_clock.hpp"

using namespace xpcc::clock;

namespace xpcc
{

namespace stm32
{

%% for source in sources

template< uint32_t Input {{ "" if source.fixed is not defined else "= "~source.fixed }} >
class
{{ source.name }}
{
	%% if source.fixed is defined
	// This clock source has a fixed frequency of {{ source.fixed }}
{{ macro.assertFrequency(source.name, "Input", "fixed", source.fixed) }}
	%% else
	// This clock source has a variable frequency between [{{ source.min }}, {{ source.max }}]
{{ macro.assertFrequency(source.name, "Input", "min", source.min) }}
{{ macro.assertFrequency(source.name, "Input", "max", source.max) }}
	%% endif
public:
	static const TypeId::{{ source.name }} Id;
	static constexpr ClockName Name = ClockName::{{ source.name }};

	static constexpr uint32_t InputFrequency = Input;
	static constexpr uint32_t OutputFrequency = InputFrequency;

public:
	static StartupError
	enable(const uint32_t waitCycles = 1500)
	{
		if (not ClockControl::enableSource(ClockControl::ClockSource::{{ source.name }}, waitCycles))
			return StartupError::{{ source.name }};
		return StartupError::None;
	}
};

%% endfor

} // namespace stm32

} // namespace xpcc

#endif	// XPCC_STM32_CLOCK_SOURCES_HPP
