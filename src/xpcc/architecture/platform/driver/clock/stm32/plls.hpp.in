/* Copyright (c) 2015, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 * ------------------------------------------------------------------------- */

%%	import '../generic/static.macros' as macro with context

#ifndef XPCC_STM32_CLOCK_PLLS_HPP
#define XPCC_STM32_CLOCK_PLLS_HPP

#include <stdint.h>		// uint16_t
#include "../../../device.hpp"
#include "../../../type_ids.hpp"
#include "../generic/common_clock.hpp"

using namespace xpcc::clock;

namespace xpcc
{

namespace stm32
{

%% for pll in plls
	%% set divisors = pll | getClockInputDivisors
	%% set multiplier = pll.multiplier | readNumberRange

/// @cond
namespace detail
{
// multiplier constants for {{ pll.name }}, must be sorted by <
static constexpr uint16_t {{ pll.name }}MultiplierCount = {{ multiplier['values'] | count }};
static constexpr uint16_t {{ pll.name }}Multipliers[{{ pll.name }}MultiplierCount] = { {{ multiplier['values'] | join(", ") }} };

	%% for name, range in divisors.items()
		%% set values = range['values']
// divisor constants for {{ name }}, must be sorted by <
static constexpr uint16_t {{ pll.name ~ name }}DivisorCount = {{ values | count }};
static constexpr uint16_t {{ pll.name ~ name }}Divisors[{{ pll.name ~ name }}DivisorCount] = { {{ values | join(", ") }} };
	%% endfor
}   // namespace detail
/// @endcond

template< class Input, uint32_t Output >
class
{{ pll.name }}
{
{{ macro.assertValidInput(pll.name, "Input", pll.inputs) }}
	/// we encode the multiplier in the upper 16 bits and the divisor in the lower 16 bits
	using mult_div_t = uint32_t;

	/// returns the signed divisor part of the combi index
	static constexpr int16_t
	getDivisorIndex(mult_div_t index)
	{ return int16_t(index & 0xffff); }
	/// returns the signed multiplier part of the combi index
	static constexpr int16_t
	getMultiplierIndex(mult_div_t index)
	{ return int16_t(index >> 16); }
	/// builds a combi index out of multiplier and divisor
	static constexpr mult_div_t
	getCombiIndex(int16_t divisor, int16_t multiplier = 0)
	{ return (uint16_t(multiplier) << 16) | uint16_t(divisor); }

	/// @param index    the start index of the search (hint: should be zero)
	/// @retval >=0 value has been found at returned index
	/// @retval -1 value has not been found
	static constexpr int16_t
	findMultiplierIndex(uint16_t value, int index = 0)
	{
		return ((index < detail::{{ pll.name }}MultiplierCount)?  // are the still multipliers left?
					((value == detail::{{ pll.name }}Multipliers[index])?   // we found the multiplier
						index:   // return the index
						findMultiplierIndex(value, index + 1)): // try the next multiplier
					-1);   // no multiplier left, value not found
	}

	%% for name, range in divisors.items()
		%% set values = range['values']
	// ---------------------------------------- {{ name }} ----------------------------------------------------
	/// @param index    the start index of the search (hint: should be zero)
	/// @retval >=0 value has been found at returned index
	/// @retval -1 value has not been found
	static constexpr int16_t
	find{{ name }}DivisorIndex(uint16_t value, int index = 0)
	{
		return ((index < detail::{{ pll.name ~ name }}DivisorCount)?  // are the still divisors left?
					((value == detail::{{ pll.name ~ name }}Divisors[index])?   // we found the divisor
						index:   // return the index
						find{{ name }}DivisorIndex(value, index + 1)): // try the next divisor
					-1);   // no divisors left, value not found
	}
	%% if range.maxFrequency is defined
	/// This method returns the index of the divisor value that is less or equal to `value`
	/// Search happens from the largest to the smallest index, therefore `index` must be the index
	/// from which to start the search. Return values are always within range of divisors, regardless of input.
	static constexpr uint16_t
	get{{ name }}DivisorMinimumIndex(uint16_t value, int index = detail::{{ pll.name ~ name }}DivisorCount - 1)
	{
		return ((value < detail::{{ pll.name ~ name }}Divisors[index])?
					((index == 0)?
						0 :
						get{{ name }}DivisorMinimumIndex(value, index - 1)):
					index);
	}
	%% endif
	%% if range.minFrequency is defined
	/// This method returns the index of the divisor value that is greater or equal to `value`
	/// Search happens from the smallest to the largest index, therefore `index` must be the index
	/// from which to start the search. Return values are always within range of divisors, regardless of input.
	static constexpr uint16_t
	get{{ name }}DivisorMaximumIndex(uint16_t value, int index = 0)
	{
		return ((value > detail::{{ pll.name ~ name }}Divisors[index])?
					((index < detail::{{ pll.name ~ name }}DivisorCount)?
						get{{ name }}DivisorMaximumIndex(value, index + 1):
						detail::{{ pll.name ~ name }}DivisorCount - 1):
					index);
	}
	%% endif
%#
	/// Returns the maximum divisor index as determined by the minimum frequency requirement on this clock path
	static constexpr uint16_t
	get{{ name }}DivisorMaximumIndex()
	{
		%% if range.minFrequency is defined
		// min frequency is {{ range.minFrequency }}
		return get{{ name }}DivisorMaximumIndex( int(std::floor(float(Input::OutputFrequency) / {{ range.minFrequency }})));
		%% else
		return detail::{{ pll.name ~ name }}DivisorCount - 1;
		%% endif
	}
	/// Returns the minimum divisor index as determined by the maximum frequency requirement on this clock path
	static constexpr uint16_t
	get{{ name }}DivisorMinimumIndex()
	{
		%% if range.maxFrequency is defined
		// max frequency is {{ range.maxFrequency }}
		return get{{ name }}DivisorMinimumIndex( int(std::ceil(float(Input::OutputFrequency) / {{ range.maxFrequency }})));
		%% else
		return 0;
		%% endif
	}

	/// returns the multiplier, divisor combi index for this clock path
	/// @retval >=0 if a match is found, use `get{{ name }}DivisorIndex` and `get{{ name }}MultiplierIndex` to get indexi
	/// @retval -1 for both indexi, if no match is found!
	static constexpr mult_div_t
	get{{ name }}MultDivIndex(mult_div_t index = get{{ name }}DivisorMinimumIndex())
	{
		// Appologies for this terrible ?: jungle, this will get better with C++14.
		// this algortihm "simply" iterates over all divisors and chooses the first integer multiplier that is within the pll range.
		return ((getDivisorIndex(index) <= get{{ name }}DivisorMaximumIndex())?  // there are still some dividers left
					((Output % (Input::OutputFrequency / detail::{{ pll.name ~ name }}Divisors[index])) == 0)? // the result of (output / (input / div)) is an integer
						(findMultiplierIndex(Output / (Input::OutputFrequency / detail::{{ pll.name ~ name }}Divisors[index])) >= 0)? // the computed divisor in the multiplier range
							getCombiIndex(getDivisorIndex(index), findMultiplierIndex(Output / (Input::OutputFrequency / detail::{{ pll.name ~ name }}Divisors[index]))):    // return both indexes
							get{{ name }}MultDivIndex(getDivisorIndex(index) + 1): // otherwise, continue searching
						get{{ name }}MultDivIndex(getDivisorIndex(index) + 1):     // otherwise, continue searching
				-1);    // no value found, return invalid index
	}

	/// @retval >=0 if valid divisor found
	/// @retval -1 if no divisor can be used
	static constexpr int16_t
	get{{ name }}DivisorIndex()
	{
		return getDivisorIndex(get{{ name }}MultDivIndex());
	}
	/// @retval >=0 if valid multiplier found
	/// @retval -1 if no multiplier can be used
	static constexpr int16_t
	get{{ name }}MultiplierIndex()
	{
		return getMultiplierIndex(get{{ name }}MultDivIndex());
	}
	/// Returns the actual computed divisor value, returns divisor[0] if invalid index.
	static constexpr uint16_t
	get{{ name }}Divisor()
	{
		return detail::{{ pll.name ~ name }}Divisors[get{{ name }}DivisorIndex() >= 0 ? get{{ name }}DivisorIndex() : 0];
	}
%#
	%% endfor
%#
	/// returns the multiplier index for the requested source
	/// @retval >=0 if valid multiplier found
	/// @retval -1 if no multiplier can be used
	static constexpr int16_t
	getPllMultiplierIndex()
	{
		return (
		%% for name, range in divisors.items()
			%% set getter = 'get' ~ name ~ 'MultiplierIndex()'
			%% if not loop.last
			( Input::Name == ClockName::{{ name }} )? {{ getter }} :(
			%% else
			{{ getter }} {{ ')' * (divisors | length) }};
			%% endif
		%% endfor
	}

	/// returns the divisor index for the requested source
	/// @retval >=0 if valid divisor found
	/// @retval -1 if no divisor can be used
	static constexpr int16_t
	getDivisorIndex()
	{
		return (
		%% for name, range in divisors.items()
			%% set getter = 'get' ~ name ~ 'DivisorIndex()'
			%% if not loop.last
			( Input::Name == ClockName::{{ name }} )? {{ getter }} :(
			%% else
			{{ getter }} {{ ')' * (divisors | length) }};
			%% endif
		%% endfor
	}

	// sanity checks
	static_assert(getPllMultiplierIndex() >= 0, "No appropriate source multiplier could be found!");
	static_assert(getDivisorIndex() >= 0, "No appropriate source divisor could be found!");

public:
	static constexpr ClockControl::{{ pll.name }}Source
	Source = (
	%% for input in pll.inputs
		%% if not loop.last
			( Input::Name == ClockName::{{ input.name }} )? ClockControl::{{ pll.name }}Source::{{ input.name }} :(
		%% else
			ClockControl::{{ pll.name }}Source::{{ input.name }} {{ ')' * (pll.inputs | length) }};
		%% endif
	%% endfor
%#
public:
	/// Returns the actual computed multiplier value for the requested source, returns multiplier[0] if invalid index.
	static constexpr uint16_t
	getMultiplier()
	{
		return detail::{{ pll.name }}Multipliers[getPllMultiplierIndex() >= 0 ? getPllMultiplierIndex() : 0];
	}

	/// Returns the actual computed divisor value for the requested source, returns divisor[0] if invalid index.
	static constexpr uint16_t
	getDivisor()
	{
		return (
		%% for name, range in divisors.items()
			%% set getter = 'get' ~ name ~ 'Divisor()'
			%% if not loop.last
			( Input::Name == ClockName::{{ name }} )? {{ getter }} :(
			%% else
			{{ getter }} {{ ')' * (divisors | length) }};
			%% endif
		%% endfor
	}

public:
	static const TypeId::{{ pll.name }} Id;
	static constexpr ClockName Name = ClockName::{{ pll.name }};

	static constexpr uint32_t InputFrequency = Input::OutputFrequency{{ ';' if (divisors | length == 0) else ' / getDivisor();' }}
	static constexpr uint32_t OutputFrequency = InputFrequency * getMultiplier();

	static StartupError
	enable(const uint32_t waitCycles = 2048)
	{
		// enable input
		StartupError err = Input::enable(waitCycles);
		// quit if failed
		if (err != StartupError::None) return err;

		// switch pll to source
	%% if usbprescaler is defined
		if (not ClockControl::enable{{ pll.name }}( Source, ClockControl::UsbPrescaler::DivideBy1Point5, getMultiplier(), getDivisor(), waitCycles ))
	%% else
		if (not ClockControl::enable{{ pll.name }}( Source, getMultiplier(), getDivisor(), waitCycles ))
	%% endif
			return StartupError::{{ pll.name }};

		return StartupError::None;
	}

private:
	static_assert((OutputFrequency == Output),
		"The generated output frequency is not equal to the requested output frequency!");

	%% for input in pll.inputs
		%% if input.min is defined
{{ macro.assertFrequencyForInput(pll.name, "Input", "min", input.min, input.name) }}
		%% endif
		%% if input.max is defined
{{ macro.assertFrequencyForInput(pll.name, "Input", "max", input.max, input.name) }}
		%% endif
	%% endfor

	%% if pll.min is defined
{{ macro.assertOutputFrequency(pll.name, "min", pll.min) }}
	%% endif
	%% if pll.max is defined
{{ macro.assertOutputFrequency(pll.name, "max", pll.max) }}
	%% endif
};

%% endfor

} // namespace stm32

} // namespace xpcc

#endif	// XPCC_STM32_CLOCK_pllS_HPP
